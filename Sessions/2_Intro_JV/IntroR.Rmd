---
title: "A Tour of (advanced) R in Sixty Minutes"
author: "Advanced R"
date: "Wednesday May 3, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Set up: form pairs with neighbor. Identify quatuor with pairs next to you.  All assignments are done in pairs. Grading is done in quatuors.

# Origins

The R programming language has its roots in S, a language created forty years ago at ATT Bell Labs by Chambers, Becker and Wilks.

The motivation for S was to simplify the task of calling statistical routines written in FORTRAN (this involved writing code to read in, format and write out the data).

The goal of S was to free users of the drudgery of writing that interface code and speed up the data analyst's workflow.  The key linguistic design principle was to design a language that could be extended and that was devoid of arbitrary limitations.

The S language was such a success that users started writing statistical routines in S.

The R programming language was designed by Ross Ihaka and Robert Gentleman at the University of Auckland around 1992.  

R departed from S in number of ways, it was an open source language released under a GPL license to ensure that everything related to R remains in the public domain, R cleaned up some corners of S and improve the performance of programs written in the language.

# Status

TODO - write about how popular / widely used R is today.

#  R from first principles

The basic building blocks of the language are surprisingly simple and elegant.

## Functions

The building block for creating abstractions in R is the *function declaration*.  These abstractions are used in *function calls*.

```{r, eval=FALSE}
f <- function( y ) {  y + 1 }
f( 1 )
```

Function definitions in R consist of an argument list and a body. The argument list is a sequence of variable names (with optional default values) and possibly one occurrence of the tripe dot symbol (`...`).  The body of the function can be a single expression or a block (`{...}`).

```{r, eval=FALSE}
# the shortest function in the book
function() 1    
# multiple expressions in the body
function( x ) { y <- x * x;  y + 1 }
# default values, optional arguments
function( x = 0, ..., y = 2)   if(length(z <- list(...) == 0)) x * y  else x * y * z[[1]] 
```

A function call consists of an expression that evaluates to a function followed by a (possibly empty) list of (possible named) arguments.

```{r, eval=FALSE}
f()
# the shortest call of them all
f(1,2)
# positional calls pass arguments in order
f(x = 1, y = 2)
f(y = 2, x = 1)
# named calls pass argument by name without a prescribed order
(x[42])(x=1)
# an expression that yields a function can be called
```

Some functions have inline syntax, `+` for example does not require parentheses and `if else` is  function which takes two arguments.  The assignment operators are functions `<-` and `[]<-, so are parenthese `(`.  All functions can be redefined.

```{r}
`+` <- function(a,b) paste(a,b)
`(` <- function(a) print("(" + a + ")")
(1 + 1)
```

**Exercise 1:** write a definition of a function `f` that will return `0`, `-1`, `1`, `1` for the four calls to `f` above and a variable `x` such that the last call returns `-1`.


Let's clean up the environment. 

```{r}
rm(`+`)
rm(`(`)
```


```{r, eval=F}
f <- function(y = 0, x = 0) x - y
f()
f(1,2)
f(x = 1, y = 2)
f(y = 2, x = 1)
```

The optional arguments have somewhat interesting semantics. In a function, any argument occurring after the three dots must be passed by name.  In the function body they can be passed as argument to a further call.

```{r, eval=F}
f <- function( x, ..., y) {  # y can only be passed by name
   l1 <- c(...)  # the tree dots become an argument list
   l2 <- c(x,...)
   l3 <- c(y,...,x)
   l1[1] + l2[2] + l3[3]
}
f(1,2,y=3)
```

**Exercise 2:** guess what value the call to `f` will return.

The rationale for having arguments after the three dots is to specify optional arguments rarely overridden.

Function evaluation is complete when the last expression in the body is evaluated. The `return()` call can break evaluation in the middle.  The `stop()` call can raise an exception that can only be caught in a `tryCatch()` statement. 

```{r, eval=F}
f <- function(x,acc) {
  if (x == 0) tryCatch( stop(simpleException("done")), 
                        simpleException = function(err) acc)
  else f(x-1, acc+1) 
}  
```


**Exercise 3:** what will happen if we evaluate `f(-1)`.

Each call to a function adds the argument to function on a data structure referred to as the *stack*. When a function returns the arguments are removed from the stack.

# Environments

An environment binds names to values. 

```{r}
e <- new.env()
e$a <- FALSE
e$b <- "a"
e$c <- 2.3
e$d <- 1:3
```

![An environment refers to values in memory.](http://adv-r.had.co.nz/diagrams/environments.png/bindings.png)

Environments can be chained by assigning to their *parent environment*.  Looking up names using `get("x", env=e)` will find the first binding for `x` in the sequence of environments starting at `e` and following the `parent` chain.


```{r}
f <- new.env()
parent.env(f) <- e
get("c", env=f)
```

Environments are used to hold the variables and parameters of a function.  The chaining is used to implement lexical scoping.

```{r}
f <- function() {
   x <- 42
   function() x
}
x <- -42
```

**Exercise 4:** what will the value of the expression `f()()`?  

Environment are also used to implement the namespaces that are exported by packages.

Consider the `sd` function, it is provided by the `stats` package.

```{r, eval=F}
environment(sd)
#> <environment: namespace:stats>
where("sd")
#> <environment: package:stats>
```

The definition of `sd()` uses funcion `var()`, but if we make our own version of `var()` it doesn’t affect `sd()`:

```{r,eval=F}
x <- 1:10
sd(x)
## [1] 3.02765
var <- function(x, na.rm = TRUE) 100
sd(x)
## [1] 3.02765
```

![](http://adv-r.had.co.nz/diagrams/environments.png/namespace.png)

When we type `var` into the console, it’s found first in the global environment. When `sd()` looks for `var()` it finds it first in its namespace environment so never looks in the `globalenv()`.


TODO read/write   <- v <<-

## Data structures

R offers a variety of built-in data structures.

### Base types

The base types include `double`, `integer`, `characater` and `logical`.  Values can be tested as belonging to one of those types.

```{r, eval=F}
typeof(1)
## [1] "double"
typeof(1L)
## [1] "integer"
is.numeric(1.1)
## [1] TRUE
is.logical(TRUE)
is.character("Hello")
```
Every base type has a sentinnel value used to represent missing observations.

```{r,eval=F}
x <- 1
x[2] <- NA
typeof(x[2])
## "double"
typeof(NA)
## logical
typeof(NA + 1L)
```

**Exercise 5:** what is the type of expression `NA + 1L`.

In practice, the difference between integers and doubles is one of space, range and accuracy.  Integers are encoded in 32 bits, they can represent values up to 2 billion operations on integers are accurate.  Doubles are floating point values stored in 64 bits which can loose precision in certain situations.

R programs do not manipulate basic types, all operations in R are vectorized.

### Vectors

R provides several kinds of compound data structrures commonly referred to as *vectors*.  All operations in R are *vectorized*, this means that they take vectors as arguments and they will operate on the individual values (basic types) of these vectors.

```{r}
x <- c(1,2,2)
y <- c(2,2,1)
( x + y ) * x
```

All vectors can be accessed used subsetting operators `[` and `[[`, and can be used with functions `typeof()` (to find out what basic type is in the vector),
`length()` (how many elements are in it), `attributes()` (query the vector's meta data).

#### Atomic vectors

Atomic vectors are homogeneous (possibly multi-dimensional) data structures.

```{r}
c(1,2,3)
c("one","two","three")
```

Element of vectors can be accessed individually.

```{r}
x <- c(1L, 2L, 3L)
x[1] <- 45
x[1]
```

The operator `[<-` is the assignment function.

A two dimensional atomic vector is called a *matrix* and higher-dimensional vector is called an *array*.

```{r}
a <- matrix(1:6, ncol = 3, nrow = 2)
b <- array(1:12, c(2,3,4))
```





#### Lists



* Subsetting
* Lazy evaluation
* Objects
* Domain specific languages
