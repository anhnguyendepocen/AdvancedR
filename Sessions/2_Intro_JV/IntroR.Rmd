---
title: "A Tour of (advanced) R in Sixty Minutes"
author: "Advanced R"
date: "Wednesday May 3, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Set up: form pairs with neighbor. Identify quatuor with pairs next to you.  All assignments are done in pairs. Grading is done in quatuors.

# Origins

The R programming language has its roots in S, a language created forty years ago at ATT Bell Labs by Chambers, Becker and Wilks.

The motivation for S was to simplify the task of calling statistical routines written in FORTRAN (this involved writing code to read in, format and write out the data).

The goal of S was to free users of the drudgery of writing that interface code and speed up the data analyst's workflow.  The key linguistic design principle was to design a language that could be extended and that was devoid of arbitrary limitations.

The S language was such a success that users started writing statistical routines in S.

The R programming language was designed by Ross Ihaka and Robert Gentleman at the University of Auckland around 1992.  

R departed from S in number of ways, it was an open source language released under a GPL license to ensure that everything related to R remains in the public domain, R cleaned up some corners of S and improve the performance of programs written in the language.

#  R from first principles

The basic building blocks of the language are surprisingly simple and elegant.

## Functions

The building block for creating abstractions in R is the *function declaration*.  These abstractions are used in *function calls*.

```{r, eval=FALSE}
f <- function( y ) {  y + 1 }
f( 1 )
```

Function definitions in R consist of an argument list and a body. The argument list is a sequence of variable names (with optional default values) and possibly one occurrence of the tripe dot symbol (`...`).  The body of the function can be a single expression or a block (`{...}`).

```{r, eval=FALSE}
# the shortest function in the book
function() 1    
# multiple expressions in the body
function( x ) { y <- x * x;  y + 1 }
# default values, optional arguments
function( x = 0, ..., y = 2)   if(length(z <- list(...) == 0)) x * y  else x * y * z[[1]] 
```

A function call consists of an expression that evaluates to a function followed by a (possibly empty) list of (possible named) arguments.

```{r, eval=FALSE}
f()
# the shortest call of them all
f(1,2)
# positional calls pass arguments in order
f(x = 1, y = 2)
f(y = 2, x = 1)
# named calls pass argument by name without a prescribed order
(x[42])(x=1)
# an expression that yields a function can be called
```

Some functions have inline syntax, `+` for example does not require parentheses and `if else` is  function which takes two arguments.  The assignment operators are functions `<-` and `[]<-, so are parenthese `(`.  All functions can be redefined.

```{r}
`+` <- function(a,b) paste(a,b)
`(` <- function(a) print("(" + a + ")")
(1 + 1)
```

**Exercise 1:** write a definition of a function `f` that will return `0`, `-1`, `1`, `1` for the four calls to `f` above and a variable `x` such that the last call returns `-1`.

```{r, eval=F}
f <- function(y = 0, x = 0) x - y
f()
f(1,2)
f(x = 1, y = 2)
f(y = 2, x = 1)
```

The optional arguments have somewhat interesting semantics. In a function, any argument occurring after the three dots must be passed by name.  In the function body they can be passed as argument to a further call.

```{r, eval=F}
f <- function( x, ..., y) {  # y can only be passed by name
   l1 <- c(...)  # the tree dots become an argument list
   l2 <- c(x,...)
   l3 <- c(y,...,x)
   l1[1] + l2[2] + l3[3]
}
f(1,2,y=3)
```

**Exercise 2:** guess what value the call to `f` will return.

The rationale for having arguments after the three dots is to specify optional arguments rarely overridden.

Function evaluation is complete when the last expression in the body is evaluated. The `return()` call can break evaluation in the middle.  The `stop()` call can raise an exception that can only be caught in a `tryCatch()` statement. 

```{r, eval=F}
f <- function(x,acc) {
  if (x == 0) tryCatch( stop(simpleException("done")), 
                        simpleException = function(err) acc)
  else f(x-1, acc+1) 
}  
```


**Exercise 3:** what will happen if we evaluate `f(-1)`.

Each call to a function adds the argument to function on a data structure referred to as the *stack*. When a function returns the arguments are removed from the stack.

# Environments

An environment binds names to values. 

```{r}
e <- new.env()
e$a <- FALSE
e$b <- "a"
e$c <- 2.3
e$d <- 1:3
```

![An environent.](http://adv-r.had.co.nz/diagrams/environments.png/bindings.png)

Environments can be chained by assigning to their *parent environment*.  Looking up names using `get("x", env=e)` will find the first binding for `x` in the sequence of environments starting at `e` and following the `parent` chain.

```{r}
f <- new.env()
parent.env(f) <- e
get("c", env=f)
```



* Data structures
* Subsetting
* Functions
* Lazy evaluation
* Environments
* Objects
* Domain specific languages

* Execution model:  names and bindings, environments

* Exceptions
* Namespaces

* Vectorization
