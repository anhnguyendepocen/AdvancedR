---
title: "Building R packages"
author: "Advanced R"
date: "Friday May 5, 2017"
output: html_document
---

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message=FALSE, warning=FALSE)
```


## Learning goals

1. When is it a good idea to build your own R packages?

2. How to build R packages

3. What are some other useful tools for building R packages?

## Why build an R package?

Even if you are not planning on distributing your code, building an R package has many advantages over `source()`-ing your R scripts.

- Easily manage and organize your code

- Portably re-use your code

- Documentation for your code

- Make dependencies on other packages explicit

- Distribute your code! (internally or externally)

## Creating an R package

An R package is really just a directory with certain required files and subdirectories. The directory layout of an R package is:

- `PACKAGE_NAME/`
    + `DESCRIPTION` : A structured description of the package
    + `NAMESPACE` : Imports package dependencies and exports your functions and classes
    + `R/` : All your R code lives here
    + `man/` : Documentation of exported R functions and classes
    + `src/` : Foreign (C, C++, Fortran, etc.) code lives here
    + `inst/` : Miscellaneous files to move into the package directory when installed
    + `data/` : `.RData` or `.rda` data files used by the package
    + `tests/` : Unit tests for the package's functions and classes
    + `vignettes/` : Vignettes illustrating the package's use
    + `NEWS` : Changelog for the package

Many of these directories are optional.

R will build and install a package with only the DESCRIPTION file and `R/` subdirectory. However, the minimal requirements for a proper package also include a NAMESPACE file and ".Rd" documentation in the `man/` subdirectory for all exported functions and classes.

All of these can be created by hand. However, some tools exist that can generate some of these automatically.

- A simple skeleton for an R package can be created using the `package.skeleton` function in the __utils__ package.

- The __roxygen2__ package can generate ".Rd" documentation and NAMESPACE file from inline code comments in a special format.

An example package called __ProtExp__ has been included, which implements the example `ProtExp` S3 class for proteomics experiments, with `normalize`, `summary`, and `plot` methods.

Take some time to look at the __ProtExp__ example package before moving on.

## Documenting an R package

R packages are documented using ".Rd" files, which are based on LaTeX.

These can be created and edited manually, or they can be generated from inline code comments using the __roxygen2__ package.

For example, the constructor for the `ProtExp` class in our example __ProtExp__ package is documented inline as follows:

```{r}
#' Proteomics Experiment
#'
#' Create a \code{ProtExp} object.
#'
#' \code{ProtExp} is a simple S3 class inheriting from \code{data.frame}
#' for storing proteomics experiments. It expects columns named
#' `protein', `feature', `run', `intensity', and `label'. Additional
#' columns are also allowed. A \code{ProtExp} object also has a
#' \code{is_log_exp} attribute for tracking whether the intensities
#' have been log2-transformed or not.
#'
#' @param protein A \code{character} vector of protein names.
#' @param feature A \code{character} vector of MS features.
#' @param run A \code{character} or \code{numeric} vector of MS runs.
#' @param intensity A \code{numeric} vector of MS intensities.
#' @param label A \code{character} or \code{factor} of MS labels.
#' @param ... Additional columns.
#' @param is_log_trans \code{TRUE} or \code{FALSE} indicating whether
#' the intensities has been log2-transformed or not.
#'
#' @return object A \code{ProtExp} object.
#'
#' @export
ProtExp <- function(protein, feature, run,
							intensity, label, ..., is_log_trans = FALSE)
{
	dots <- list(...)
	if ( length(dots) > 0 ) {
		object <- data.frame(protein=protein, feature=feature,
			run=run, intensity=intensity, label=label, list(...)) 
	} else {
		object <- data.frame(protein=protein, feature=feature,
			run=run, intensity=intensity, label=label) 
	}
	attr(object, "is_log_trans") <- is_log_trans
	class(object) <- c("ProtExp", "data.frame")
	object
}
```

We can run `roxygenize()` on the __ProtExp__ directory to generate ".Rd" documentation.

```{r, eval=FALSE}
library(roxygen2)
roxygenize("ProtExp")
```

This generates the following ".Rd" documentation for the `ProtExp` constructor function.

```{}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ProtExp.R
\name{ProtExp}
\alias{ProtExp}
\title{Proteomics Experiment}
\usage{
ProtExp(protein, feature, run, intensity, label, ..., is_log_trans = FALSE)
}
\arguments{
\item{protein}{A \code{character} vector of protein names.}

\item{feature}{A \code{character} vector of MS features.}

\item{run}{A \code{character} or \code{numeric} vector of MS runs.}

\item{intensity}{A \code{numeric} vector of MS intensities.}

\item{label}{A \code{character} or \code{factor} of MS labels.}

\item{...}{Additional columns.}

\item{is_log_trans}{\code{TRUE} or \code{FALSE} indicating whether
the intensities has been log2-transformed or not.}
}
\value{
object A \code{ProtExp} object.
}
\description{
Create a \code{ProtExp} object.
}
\details{
\code{ProtExp} is a simple S3 class inheriting from \code{data.frame}
for storing proteomics experiments. It expects columns named
`protein', `feature', `run', `intensity', and `label'. Additional
columns are also allowed. A \code{ProtExp} object also has a
\code{is_log_exp} attribute for tracking whether the intensities
have been log2-transformed or not.
}
```

## Building and installing an R package

R packages must be built before they can be installed. This is done at the command line using `R CMD build`.

We can build the example __ProtExp__ package from R using the `system()` function to run `R CMD build`.

```{r, eval=FALSE}
system("R CMD build ProtExp")
```

It is often good to run `R CMD check`, which checks your R package for common problems.

```{r, eval=FALSE}
system("R CMD check ProtExp_1.0.tar.gz")
```

Our package can then be installed from R using `install.packages()`.

```{r, eval=FALSE}
install.packages("ProtExp_1.0.tar.gz",
                 repos=NULL, type="source")
```

We can load the package, check the dataset, and try the functions:

```{r}
library(ProtExp)
library(tidyverse)

data(twin)
twin_dia2 <- twin_dia %>%
  rename(heavy = intensity_h, light = intensity_l) %>% 
  gather(label, intensity, heavy, light)

exp1 <- ProtExp(protein=twin_dia2$protein,
                               feature=twin_dia2$feature,
                               run=twin_dia2$run,
                               intensity=twin_dia2$intensity,
                               label=twin_dia2$label)
head(exp1)
exp1norm <- normalize(exp1, by="heavy")
head(summary(exp1norm)[,,"light"])
plot(exp1norm)
```

## Testing packages

It is often important to test snippets of code you include in your packages. A unit test suite is typically the best way to do this. Unit tests allow testing small, controlled portions of code with known return values.

Having a suite of unit tests can take some time investment at the beginning of development, but often makes things easier in the future.

There are multiple R packages that ease writing of unit tests, including __RUnit__ and __testthat__.

For example, say we have a function `foo` that we want to test.

```{r}
foo <- function(x, y) x + y
```

Then with __RUnit__:

```{r}
library(RUnit)
checkEquals(foo(1, 1), 2)
```

And with __testthat__:

```{r}
library(testthat)
expect_equal(foo(1, 1), 2)
```

Our example __ProtExp__ package includes a small example unit test suite using __testthat__.

Idealy, unit tests should cover as much code in a package as is reasonably possible.

## Package vignettes

Package vignettes go in the `/vignettes` subdirectory, and can be written in Sweave (a LaTeX-based format) or in Markdown. These are created and installed automatically with a package.

Our __ProtExp__ example package includes a Markdown vignette, which can be viewed using:

```{r}
vignette("ProtExp-demo")
```


