---
title: "Object-oriented programming in R"
author: "Advanced R"
date: "Friday May 5, 2017"
output: html_document
---

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message=FALSE, warning=FALSE)
```


## Learning goals

1. Understand what is object-oriented programming and when to use it.

2. What are the ways to use object-oriented programming in R?

## What is object-oriented programming (OOP)?

OOP is a way of organizing code around commonly re-used data "classes" and "methods".

A **class** is a blueprint for a way of organizing data.

- E.g., you might write a class for a proteomics experiment.

An **object** is a particular instance of a class.

- E.g., the twin case study is a particular instance of a proteomics experiment.

Using **inheritance** allows *subclasses* to specialize *superclasses*.

- E.g., a DIA or SRM class which specializes a proteomics experiment class.

A **method** is a function associated with behavior specialized to a particular class. In __R__ this is done using *generic functions*.

- E.g., `plot` is a generic function. A proteomics experiment class may have a `plot` method that knows how to plot proteomics experiments.

## A simple example

Consider a pet simulator game. It may consist of the following elements:

- An `Animal` class with subclasses `Cat` and `Dog`.

- A generic function called `speak`.

- A `speak` method for both the `Cat` and `Dog` classes

- An object named `Mittens` as an instance of the `Cat` class

- An object named `Duke` as an instance of the `Dog` class

- `speak(Mittens)`
    + `"Meow!"`

- `speak(Duke)`
    + `"Woof!"`

## OOP in R

There are two major object-oriented programming systems in R.

- S3 classes
    + Very simple class system
    + No formal class definitions
    + Single dispatch (methods only specialized on first argument)
    + Single inheritance

- S4 classes
    + More complex class system
    + Formal class definitions
    + Multiple dispatch (methods specialized on multiple arguments)
    + Multiple inheritance
    
When to use which?

- Use S3 for simple data structures without complex dependencies

- Use S4 for more complex data structures

S3 is more common in base R and CRAN packages.

S4 is more common in Bioconductor packages.

## Introduction to S3 classes

S3 classes are created from base R types with `attribute`s.

That means S3 classes are based on:

- `raw`
- `integer`
- `numeric`
- `character`
- `list`

...etc.

S3 classes are defined by their `class` attribute which can be accessed and set by the `class()` function

What are some common S3 classes you already use in R?

- `factor`

- `data.frame`

```{r}
# investigate factors
fc <- factor(c("a", "a", "b", "c"))
class(fc)
typeof(fc) # built on top of 'integer' base type
attributes(fc) # has 'class' and 'levels' attributes
```

```{r}
# investigate data.frames
df <- data.frame(x=1:3, y=4:6)
class(df)
typeof(df) # built on top of 'list' base type
attributes(df) # has 'class', 'names', and 'row.names' attributes
```

```{r}
class(df) <- "list"
df
class(df) <- "data.frame"
df
```

S3 classes can inherit from other S3 classes by simply appending the superclass to the `class` attribute.

For example, for an ordered factor:

```{r}
od <- ordered(c("a", "a", "b", "c"))
class(od) # class 'ordered' inherits from 'factor'
```

## Introduction to S3 methods

A generic function is a function that should behave differently depending on what kind of object is it given.

S3 generic functions are defined by a body consisting of `UseMethod("name")` (where "name" is the name of the function).

S3 methods are then defined by the naming scheme `name.class()`.

Available methods can be listed using the `methods()` function.

What are some common S3 methods you already use in R?

- `print`

- `plot`

- `summary`

```{r}
print # its body uses 'UseMethod', so it's a generic function
head(methods("print")) # there are a lot of 'print' methods
plot # plot is also a generic function with UseMethod("plot")
head(methods("plot")) # 'plot' has a lot of methods too
summary # summary is a generic function with UseMethod("summary")
head(methods("summary")) # 'summary' also has many methods
```

S3 methods are how R (almost) always knows how to print, plot, summarize, etc. whatever objects you give it, appropriately for each object type.

## Create an S3 class and methods

Earlier, we learned how to write functions and how to normalize, summarize, and plot proteomics experiments.

These are things we would like to do again whenever we get a new proteomics experiment dataset, but also which should (reasonably) behave differently for different types of experiments.

In addition, `plot` and `summary` are already generic functions in R, and `normalize` is a good candidate to be a generic function, too.

In this section, we will:

- Create an S3 class called `S3ProteomicsExperiment`

- Create a `normalize` S3 generic function

- Create `normalize`, `summary`, and `plot` methods for our class

Because S3 classes are not rigorously defined by anything except the `class` attribute, the first step is to write a function for creating `S3ProteomicsExperiment` objects.

We decide, at minimum, a valid proteomics experiment should have proteins, features, intensities, labels, and runs. For simplicity, our proteomics experiment class will inherit from `data.frame`.

```{r}
S3ProteomicsExperiment <- function(protein, feature, run, intensity, label, ..., log2 = FALSE)
{
  dots <- list(...)
  if ( length(dots) > 0 ) {
    object <- data.frame(protein=protein, feature=feature,
         run=run, intensity=intensity, label=label, list(...)) 
  } else {
    object <- data.frame(protein=protein, feature=feature,
         run=run, intensity=intensity, label=label) 
  }
  attr(object, "log2") = log2
  class(object) <- c("S3ProteomicsExperiment", "data.frame")
  object
}
```

Notice that we handle `...` as an argument to allow additional variables to be added to the proteomics experiment.

We also include an attribute for tracking whether the intensities are log_2 transformed or not.

```{r}
library(tidyverse)
load("../data/adv-R-twin.RData")
twin_dia2 <- twin_dia %>%
  rename(heavy = intensity_h, light = intensity_l) %>% 
  gather(label, intensity, heavy, light)

exp1 <- S3ProteomicsExperiment(protein=twin_dia2$protein,
                               feature=twin_dia2$feature,
                               run=twin_dia2$run,
                               intensity=twin_dia2$intensity,
                               label=twin_dia2$label)
head(exp1)
```

Because `S3ProteomicsExperiment` inherits from `data.frame`, it inherits the `print` method for data.frames.

Now, we write a `normalize` method for our class. Since `normalize` is not already an S3 generic function, we first create an S3 generic function called `normalize`.

```{r}
normalize <- function(object, ...) UseMethod("normalize")

normalize.S3ProteomicsExperiment <- function(object, ..., by) {
  if ( !attr(object, "log2") ) {
    object$intensity <- log2(object$intensity)
    attr(object, "log2") <- TRUE
  }
  std <- object$label == by
  medians <- tapply(object$intensity[std], object$run[std],
                    median, na.rm=TRUE)
  gbl_median <- median(medians, na.rm=TRUE)
  object$intensity <- object$intensity - medians[object$run] + gbl_median
  object
}
```

Now we write methods for `summary` and `plot`:

```{r}
summary.S3ProteomicsExperiment <- function(object, ...) {
  if ( attr(object, "log2") )
    object$intensity <- 2^object$intensity
  tapply(object$intensity,
         list(run=object$run,
              protein=object$protein,
              label=object$label),
         function(x) log2(sum(x, na.rm=TRUE)))
}

plot.S3ProteomicsExperiment <- function(object, ...) {
  if ( attr(object, "log2") ) {
    ylab <- "log2(intensity)"
  } else {
    ylab <- "intensity"
  }
  boxplot(object$intensity ~ object$run, xlab="run", ylab=ylab)
}
```

Now we can do:

```{r}
exp2 <- normalize(exp1, by="heavy")
head(summary(exp2)[,,"light"])
plot(exp2)
```

## Create an S4 class and methods



